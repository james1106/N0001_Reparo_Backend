contract Reparo{
    address owner;
    function Reparo(){
        owner = msg.sender;
    }

    enum RoleCode { RC00, RC01,RC02,RC03 } //RC00融资企业, RC01物流公司,RC02仓储公司,RC03金融机构
    enum AccountState { VALID, INVALID, FROZEN } //账户状态，有效、无效、冻结
    enum OrderState {UNCOMFIRMED, COMFIRMED} //UNCOMFIRMED-待卖方确认，COMFIRMED-卖方已确认
    enum ResponseType { YES, NO, NULL } //YES-同意，NO-拒绝，NULL-五
    enum ReceivableState{RB000001 ,//已结清
                         RB000002 ,//已作废
                         RB000003,//签收拒绝
                         RB020001,//承兑待签收
                         RB020006,//承兑已签收
                         RB030001,//已兑付
                         RB030006,//已部分兑付
                         RB030009,//兑付失败
                         B070001,//贴现待签收
                         RB070006,//贴现已签收
                         RB070008,//已部分贴现
                         RB070009//已全额贴现
          }

    //应收款
    struct Receivable {
        bytes32 receivableId;//应收款id，
        address payerPubkey; //付款人（签收人）
        address payeePubkey; //收款人（签发人）
        address OwnerPubkey;//本手持有人
        address nextOwnerPubkey;//下手持有人
        uint    isseAmt; //票面金额
        uint    cashedAmount;//已兑付金额
        ReceivableState status;//应收款状态
        ReceivableState lastStatus;//上一状态
        uint    isseDat; //签发日
        uint    signInDat;//签收日，根据时间筛选的参照对象
        uint    expiryDate;//签收有效期
        uint    dueDt; //到期日
        bytes   note;//备注
    }

    //帐户信息
    struct Account{
        address     publicKey;//公钥
        bytes32     nickName;//用户名
        bytes32     companyName;//企业名称
        RoleCode    roleCode;//角色
        AccountState accountState;//
    }

    //订单
    struct Order{
        bytes32     orderId;//订单编号
        address     payerPubkey;//买方id
        address     payeePubkey;//卖方（供应商id）
        bytes32     productName;//货品名称. -->test productName，unitPrice，productNum待确认是否需要使用数组，若需要的话addOrder中的参数如何传
        uint        unitPrice;//货品单价
        uint        productNum;//货品数量
        uint        totalPrice;//订单总价
        uint        timeStamp;//订单生成时间
        OrderState  orderState  ;//订单状态
    }

    //操作记录
    struct ReceivableRecord {
        bytes32 receivableId;//应收款编号
        bytes32 serialNum;//流水号
        address applicantPubkey;//申请人账号
        address replyerPubkey;//回复人账号
        ResponseType responseType;//回复意见
        uint time;//时间戳
        bytes32 operateType; //操作类型 enum申请、确认
        uint dealAmount;//操作金额
    }

    // 用户公钥 => 结构体Account
    mapping( address => Account) accountMap;

    // 订单id => 处理订单详情
    mapping( bytes32 => Order ) orderDetailMap;

    // 账号 => 所有订单列表（包含现在持有和历史订单）
    mapping(address => bytes32[]) allOrderMap;

    // 用户公钥 => 待处理订单编号列表
    mapping( address => bytes32[]) pendingOrederMap;

    // 应收款编号 => 应收款详情
    mapping( bytes32 => Receivable) receivableDetailMap;

    // 用户公钥 => 所有应收款列表(包含现在持有和历史上曾经持有的)
    mapping( address => bytes32[]) allReceivableMap;

    //用户持有应收款列表, 用户address =>用户当前持有的应收款编号列表
    mapping(address => bytes32[]) holdingReceivables;

    //  用户公钥 => 待处理应收款列表
    mapping( address => bytes32[]) pendingReceivables;

    //操作记录流水号 => 操作记录详情
    mapping(bytes32 => ReceivableRecord) recordDetailMap;

   //用户已兑付列表,用户公钥 => 已兑付应收款编号列表
    mapping(address => bytes32[]) cashedReceivables;

    //买方新增待确认订单 test待补充入参校验
    //卖方"0xca35b7d915458ef540ade6068dfe2f44e8fa733c" 买方"0x14723a09acff6d2a60dcdf7aa4aff308fddc160c"
    //111,"0xca35b7d915458ef540ade6068dfe2f44e8fa733c","productname",100,100,10000,20170101
    function addOrder (bytes32 orderId,
                       address payeePubkey, //卖方公钥
                       bytes32 productName,
                       uint unitPrice,
                       uint productNum,
                       uint totalPrice,
                       uint timeStamp) returns(uint, bool){
       orderDetailMap[orderId].orderId = orderId;
       orderDetailMap[orderId].payerPubkey = msg.sender; //买方公钥
       orderDetailMap[orderId].payeePubkey = payeePubkey;//卖方公钥
       orderDetailMap[orderId].productName = productName;
       orderDetailMap[orderId].unitPrice = unitPrice;
       orderDetailMap[orderId].productNum = productNum;
       orderDetailMap[orderId].totalPrice = totalPrice;
       orderDetailMap[orderId].timeStamp = timeStamp;
       orderDetailMap[orderId].orderState = OrderState.UNCOMFIRMED;

       allOrderMap[msg.sender].push(orderId);//买方的所有订单
       allOrderMap[payeePubkey].push(orderId);//卖方的所有订单


       //pendingOrederMap[msg.sender].push(orderId);//买方的待处理订单
       pendingOrederMap[payeePubkey].push(orderId);//卖方的待处理订单

       return (0,true);
    }

    function orderExists(bytes32 orderId) returns(uint,bool){
       Order order = orderDetailMap[orderId];
       if(order.orderId == 0 ) return(1,false);
       return(0,true);
    }

     //根据订单id获取订单详情。--test 待补充判断订单是否存在
    function queryOrderDetail(bytes32 orderId)  returns (uint,bytes32,address,address,bytes32,uint,uint,uint,uint,OrderState){
       Order order = orderDetailMap[orderId];

       return (0,
              order.orderId,
              order.payerPubkey,
              order.payeePubkey,
              order.productName,
              order.unitPrice,
              order.productNum,
              order.totalPrice,
              order.timeStamp,
              order.orderState);
       //return (0,true);
    }

    //查询用户的待处理订单列表
    function getPendingOrederList(address pubkey) returns(uint,bytes32[]){
       return (0,pendingOrederMap[pubkey]);
    }

    //卖方确认订单
    function orderConfirm(bytes32 orderId) returns(uint,bool){
        Order order = orderDetailMap[orderId];
        if (order.payeePubkey != msg.sender) {return (22,false);}//仅订单的供应商可进行确认操作
        orderDetailMap[orderId].orderState = OrderState.COMFIRMED;//修改订单详情map中的订单状态

        //allOrderMap[msg.sender] = OrderState.UNCOMFIRMED;//将该订单从卖方待处理map中移除
        deleteArrayElement(pendingOrederMap[msg.sender],orderId);
        return (0,true);
    }

    //从数组中删除某个元素
    function deleteArrayElement(bytes32[] storage a, bytes32 receivableNum) internal {
        uint position;
        for(uint i = 0; i < a.length; i++) {
            if(a[i] == receivableNum) {
                position = i;
                break;
            }
            position++;
        }
        if(position != a.length) {
            a[position] = a[a.length-1];
            a.length = a.length-1;
        }
    }

}